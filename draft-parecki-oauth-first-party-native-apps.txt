



Web Authorization Protocol                                    A. Parecki
Internet-Draft                                                      Okta
Intended status: Standards Track                             G. Fletcher
Expires: 1 January 2024                            Capital One Financial
                                                            P. Kasselman
                                                               Microsoft
                                                            30 June 2023


             OAuth 2.0 for First-Party Native Applications
           draft-parecki-oauth-first-party-native-apps-latest

Abstract

   This document extends the OAuth 2.0 Authorization Framework [RFC6749]
   with a new endpoint authorization_challenge_endpoint to support
   first-party native applications that want to control the process of
   obtaining authorization from the user using a native experience.

   In many cases, this can provide an entirely browserless experience
   suited for native applications, only delegating to the browser in
   unexpected, high risk, or error conditions.

   While a fully-delegated approach using the redirect-based
   Authorization Code grant is generally preferred, this draft provides
   a mechanism for the client to directly interact with the user.  This
   requires a high degree of trust between the authorization server and
   the client, as there typically is for first-party applications.  It
   should only be considered when there are usability concerns with a
   redirect-based approach, such as for native mobile or desktop
   applications.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://aaronpk.github.io/oauth-first-party-native-apps/draft-
   parecki-oauth-first-party-native-apps.html.  Status information for
   this document may be found at https://datatracker.ietf.org/doc/draft-
   parecki-oauth-first-party-native-apps/.

   Discussion of this document takes place on the Web Authorization
   Protocol Working Group mailing list (mailto:oauth@ietf.org), which is
   archived at https://mailarchive.ietf.org/arch/browse/oauth/.
   Subscribe at https://www.ietf.org/mailman/listinfo/oauth/.

   Source for this draft and an issue tracker can be found at
   https://github.com/aaronpk/oauth-first-party-native-apps.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 1 January 2024.

Copyright Notice

   Copyright (c) 2023 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Usage and Applicability
     1.2.  Limitations of this specification
   2.  Conventions and Definitions
     2.1.  Terminology
   3.  Protocol Overview
     3.1.  Initial Authorization Request
     3.2.  Refresh Token Request
     3.3.  Resource Request
   4.  Protocol Endpoints
     4.1.  Authorization challenge endpoint
     4.2.  Token endpoint
   5.  Authorization Initiation
     5.1.  Authorization Challenge Request
     5.2.  Authorization Challenge Response
       5.2.1.  Authorization Code Response
       5.2.2.  Error Response
     5.3.  Device Session
   6.  Token Request
     6.1.  Token Endpoint Error Response
   7.  Resource Server Error Response
   8.  Authorization Server Metadata
   9.  Security Considerations
     9.1.  First-Party Applications
     9.2.  Phishing
     9.3.  Client Authentication
     9.4.  Sender Constrained Tokens
       9.4.1.  Demonstrating Proof-of-Possession
       9.4.2.  Other Proof of Possession Mechanisms
       9.4.3.  Device Session
     9.5.  Multiple Applications
       9.5.1.  Experience Risk
       9.5.2.  Technical Risk
       9.5.3.  Mitigation
   10. IANA Considerations
   11. References
     11.1.  Normative References
     11.2.  Informative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   TODO: Key points to address include problem description, the
   relationship to the step-up authentication spec (use of acr etc.),
   properties of the protocol (extensibility etc).

1.1.  Usage and Applicability

   TODO: Prerequisites for using this specification

   *  MUST only be used by first-party applications, when the
      authorization server and application are operated by the same
      entity and the user understands them both as the same entity.

   *  MUST NOT be used by third party applications, SHOULD take measures
      to prevent use by third party applications. (e.g. only enable for
      certain client IDs, and take measures to authenticate your apps.)

   This specification is designed to be used by native applications,
   which includes both mobile and desktop applications.

   If you have multiple apps, there may be better ways of sharing a
   user's login between the apps other than each app implementing this
   specification or using an SDK that implements this specification.
   For example, [OpenID.Native-SSO] provides a mechanism for one app to
   obtain new tokens by exchanging tokens from another app, without any
   user interaction.  See Section 9.5 for more details.

1.2.  Limitations of this specification

   It's important to remember that the scope of this specification is
   limited to 1st party native applications.  Please review the entirety
   of Section 9 and when more than one 1st party native application is
   supported, Section 9.5.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.1.  Terminology

   This specification uses the terms "Access Token", "Authorization
   Code", "Authorization Endpoint", "Authorization Server" (AS),
   "Client", "Client Authentication", "Client Identifier", "Client
   Secret", "Grant Type", "Protected Resource", "Redirection URI",
   "Refresh Token", "Resource Owner", "Resource Server" (RS) and "Token
   Endpoint" defined by [RFC6749].

   TODO: Replace RFC6749 references with OAuth 2.1

3.  Protocol Overview

   There are three primary ways this specification extends various parts
   of an OAuth system.

3.1.  Initial Authorization Request

                                                   +-------------------+
                                                   |   Authorization   |
                             (B)Authorization      |      Server       |
                +----------+    Challenge Request  |+-----------------+|
   (A)Client+---|  Native  |---------------------->||  Authorization  ||
      Starts|   |  Client  |                       ||   Challenge     ||
      Flow  +-->|          |<----------------------||    Endpoint     ||
                |          | (C)Authorization      ||                 ||
                |          |    Error Response     ||                 ||
                |          |         :             ||                 ||
                |          |         :             ||                 ||
                |          | (D)Authorization      ||                 ||
                |          |    Challenge Request  ||                 ||
                |          |---------------------->||                 ||
                |          |                       ||                 ||
                |          |<----------------------||                 ||
                |          | (E) Authorization     |+-----------------+|
                |          |     Code Response     |                   |
                |          |                       |                   |
                |          |                       |                   |
                |          |                       |                   |
                |          | (F) Token             |                   |
                |          |     Request           |+-----------------+|
                |          |---------------------->||      Token      ||
                |          |                       ||     Endpoint    ||
                |          |<----------------------||                 ||
                |          | (G) Access Token      |+-----------------+|
                |          |                       |                   |
                +----------+                       +-------------------+

   Figure: Native Client Authorization Code Request

   *  (A) The native client starts the flow, by presenting the user with
      a "sign in" button, or collecting information from the user, such
      as their email address or username.

   *  (B) The client initiates the authorization request by making a
      POST request to the Authorization Challenge Endpoint, optionally
      with information collected from the user (e.g. email or username)

   *  (C) The authorization server determines whether the information
      provided to the Authorization Challenge Endpoint is sufficient to
      grant authorization, and either responds with an authorization
      code or responds with an error.  In this example, it determines
      that additional information is needed and responds with an error.
      The error may contain additional information to guide the Client
      on what information to collect next.  This pattern of collecting
      information, submitting it to the Authorization Challenge Endpoint
      and then receing an error or authroization code may repeat several
      times.

   *  (D) The client gathers additional information (e.g. passkey, or
      one-time code from email) and makes a POST request to the
      Authorization Challenge Endpoint.

   *  (E) The Authorization Challenge Endpoint returns an authorization
      code.

   *  (F) The native client sends the authorization code received in
      step (E) to obtain a token from the Token Endpoint.

   *  (G) The Authorization Server returns an Access Token from the
      Token Endpoint.

3.2.  Refresh Token Request

   When the client uses a refresh token to obtain a new access token,
   the authorization server MAY respond with an error to indicate that
   re-authorization of the user is required.

3.3.  Resource Request

   When making a resource request to a resource server, the resource
   server MAY respond with an error according to OAuth 2.0 Step-Up
   Authentication Challenge Protocol, indicating that re-authorization
   of the user is required.

4.  Protocol Endpoints

4.1.  Authorization challenge endpoint

   The authorization challenge endpoint is a new endpoint defined by
   this specification which the native application uses to obtain an
   authorization code.

   The authorization challenge endpoint is an HTTP API at the
   authorization server that accepts HTTP POST requests with parameters
   in the HTTP request message body using the application/x-www-form-
   urlencoded format.  This format has a character encoding of UTF-8, as
   described in Appendix B of [RFC6749].  The authorization challenge
   endpoint URL MUST use the "https" scheme.

   Authorization servers supporting this specification SHOULD include
   the URL of their authorization challenge endpoint in their
   authorization server metadata document [RFC8414] using the
   authorization_challenge_request_endpoint parameter as defined in
   Section 8.

   The endpoint accepts the authorization request parameters defined in
   [RFC6749] for the authorization endpoint as well as all applicable
   extensions defined for the authorization endpoint.  Some examples of
   such extensions include Proof Key for Code Exchange (PKCE) [RFC7636],
   Resource Indicators [RFC8707], and OpenID Connect [OpenID].  It is
   important to note that some extension parameters have meaning in a
   web context but don't have meaning in a native mechanism (e.g.
   response_mode=query).  It is out of scope as to what the AS does in
   the case that an extension defines a parameter that is has no meaning
   in this use case.

   The client initiates the authorization flow with or without
   information collected from the user (e.g. a passkey or MFA code).

   The authorization challenge endpoint response is either an
   authorization code or an error code, and may also contain a
   device_session which the client uses on subsequent requests to the
   authorization challenge endpoint.

4.2.  Token endpoint

   The token endpoint is used by the client to obtain an access token by
   presenting its authorization grant or refresh token, as described in
   Section 3.2 of OAuth 2.0 [RFC6749].

   This specification extends the token endpoint response to allow the
   authorization server to indicate that further authentication of the
   user is required.

5.  Authorization Initiation

   A client may wish to initiate an authorization flow by first
   prompting the user for their user identifier or other account
   information.  The authorization challenge endpoint is a new endpoint
   to collect this login hint and direct the client with the next steps,
   whether that is to do an MFA flow, or perform an OAuth redirect-based
   flow.

5.1.  Authorization Challenge Request

   The client makes a request to the authorization challenge endpoint by
   adding the following parameters, as well as parameters from any
   extensions, using the `application/x-www-form-urlencoded format with
   a character encoding of UTF-8 in the HTTP request body:

   "client_id":  REQUIRED if the client is not authenticating with the
      authorization server.

   "scope":  OPTIONAL.  The OAuth scope defined in [RFC6749].

   "acr_values":  OPTIONAL.  The acr_values requested by the client.

   "device_session":  OPTIONAL.  If the client has previously obtained a
      device session, described in Section 5.3.

   Specific implementations as well as extensions to this specification
   MAY define additional parameters to be used at this endpoint.

   For example, the client makes the following request to initiate a
   flow given the user's phone number, line breaks shown for
   illustration purposes only:

   POST /authorize HTTP/1.1
   Host: server.example.com
   Content-Type: application/x-www-form-urlencoded

   login_hint=%2B1-310-123-4567&scope=profile
   &client_id=bb16c14c73415

5.2.  Authorization Challenge Response

   The authorization server determines whether the information provided
   up to this point is sufficient to issue an authorization code, and
   responds with an authorization code or an error message.

5.2.1.  Authorization Code Response

   The authorization server issues an authorization code by creating an
   HTTP response content using the application/json media type as
   defined by [RFC8259] with the following parameters and an HTTP 200
   (OK) status code:

   "authorization_code":  REQUIRED.  The authorization code issued by
      the authorization server.

   For example,

   HTTP/1.1 200 OK
   Content-Type: application/json;charset=UTF-8
   Cache-Control: no-store

   {
     "authorization_code": "uY29tL2F1dGhlbnRpY"
   }

5.2.2.  Error Response

   If the request contains invalid parameters or incorrect data, the
   authorization server responds with an HTTP 400 (Bad Request) status
   code (unless specified otherwise) and includes the following
   parameters with the response:

   "error":  REQUIRED.  A single ASCII [USASCII] error code from the
      following:

      "invalid_request":  The request is missing a required parameter,
         includes an unsupported parameter value, repeats a parameter,
         includes multiple credentials, utilizes more than one mechanism
         for authenticating the client, or is otherwise malformed.

      "invalid_client":  Client authentication failed (e.g., unknown
         client, no client authentication included, or unsupported
         authentication method).  The authorization server MAY return an
         HTTP 401 (Unauthorized) status code to indicate which HTTP
         authentication schemes are supported.  If the client attempted
         to authenticate via the Authorization request header field, the
         authorization server MUST respond with an HTTP 401
         (Unauthorized) status code and include the WWW-Authenticate
         response header field matching the authentication scheme used
         by the client.

      "unauthorized_client":  The authenticated client is not authorized
         to use this authorization grant type.

      "invalid_scope":  The requested scope is invalid, unknown,
         malformed, or exceeds the scope granted by the resource owner.

      Values for the error parameter MUST NOT include characters outside
      the set %x20-21 / %x23-5B / %x5D-7E.

      TODO: The authorization server MAY extend these error codes with
      custom messages based on the requirements of the authorization
      server.

   "error_description":  OPTIONAL.  Human-readable ASCII [USASCII] text
      providing additional information, used to assist the client
      developer in understanding the error that occurred.  Values for
      the error_description parameter MUST NOT include characters
      outside the set %x20-21 / %x23-5B / %x5D-7E.

   "error_uri":  OPTIONAL.  A URI identifying a human-readable web page
      with information about the error, used to provide the client
      developer with additional information about the error.  Values for
      the error_uri parameter MUST conform to the URI-reference syntax
      and thus MUST NOT include characters outside the set %x21 /
      %x23-5B / %x5D-7E.

   "device_session":  OPTIONAL.  The device session allows the
      authorization server to associate subsequent requests by this
      client with an ongoing authorization request sequence.  The client
      MUST include the device_session in follow-up requests to the
      challenge endpoint if it receives one along with the error
      response.

   The parameters are included in the content of the HTTP response using
   the application/json media type as defined by [RFC7159].  The
   parameters are serialized into a JSON structure by adding each
   parameter at the highest structure level.  Parameter names and string
   values are included as JSON strings.  Numerical values are included
   as JSON numbers.  The order of parameters does not matter and can
   vary.

   The authorization server MAY define additional parameters in the
   response depending on the implmentation.

5.3.  Device Session

   The device session is completely opaque to the client, and as such
   the AS MUST adequately protect the value from inspection by the
   client, for example by using a JWE if the AS is not maintaining state
   on the backend.

   The client MUST include the device session in future requests to the
   authorization challenge endpoint for the particular authorization
   request.

6.  Token Request

   The client makes a request to the token endpoint using the
   authorization code it obtained from the authorization challenge
   endpoint, according to Section 4.1.3 of [RFC6749].

   TODO: Would it be better to define our own grant type instead of
   overloading the authorization code grant type?  Probably, since there
   won't be a redirect_uri.

   TODO: In any case, document the parameters here.

6.1.  Token Endpoint Error Response

   Upon any request to the token endpoint, including a request with a
   valid refresh token, the authorization server can respond with an
   authorization challenge instead of a successful access token
   response.

   An authorization challenge error response is a particular type of
   error response as defined in Section 5.2 of OAuth 2.0 [RFC6749] where
   the error code is set to the following value:

   (TODO: This value needs a better name)

   "authorization_required":  The authorization grant is insufficiently
      authorized, but another access token request may succeed if an
      additional authorization grant is presented.

   "device_session":  OPTIONAL.  The device session allows the
      authorization server to associate subsequent requests by this
      client with an ongoing authorization request sequence.  The client
      MUST include the device_session in follow-up requests to the
      challenge endpoint if it receives one along with the error
      response.

   For example:

   HTTP/1.1 403 Forbidden
   Content-Type: application/json;charset=UTF-8
   Cache-Control: no-store

   {
     "error": "authorization_required",
     "device_session": "uY29tL2F1dGhlbnRpY"
   }

7.  Resource Server Error Response

   Step-Up Authentication defines a mechanism for resource servers to
   tell the client to start a new authorization request, including
   acr_values and max_age, and scope from RFC6750.  Upon receiving this
   request, the client starts a new authorization request according to
   this specification, and includes the acr_values, max_age and scope
   returned in the error response.

   (No new things need to be defined by this specification in order to
   use this.)

8.  Authorization Server Metadata

   The following authorization server metadata parameters [RFC8414] are
   introduced to signal the server's capability and policy with respect
   to 1st Party Native Applications.

9.  Security Considerations

9.1.  First-Party Applications

   Because this specification enables a client application to interact
   directly with the end user, and the application handles sending any
   information collected from the user to the authorization server, it
   is expected to be used only for first-party applications when the
   authorization server also has a high degree of trust of the client.

   First-party applications are applications that the user recognizes as
   belonging to the same brand as the authorization server.  For
   example, a bank publishing their own mobile application.

9.2.  Phishing

   There are two ways using this specification increases the risk of
   phishing.

   With this specification, the client interacts directly with the end
   user, collecting information provided by the user and sending it to
   the authorization server.  If an attacker impersonates the client and
   successfully tricks a user into using it, they may not realize they
   are giving their credentials to the malicious application.

   In a traditional OAuth deployment using the redirect-based
   authorization code flow, the user will only ever enter their
   credentials at the authorization server, and it is straightforward to
   explain to avoid entering credentials in other "fake" websites.  By
   introducing a new place the user is expected to enter their
   credentials using this specification, it is more complicated to teach
   users how to recognize other fake login prompts that might be
   attempting to steal their credentials.

   Because of these risks, the authorization server MAY decide to
   require that the user go through a redirect-based flow at any stage
   of the process based on its own risk assessment.

9.3.  Client Authentication

   Typically, mobile and desktop applications are considered "public
   clients" in OAuth, since they cannot be shipped with a statically
   configured set of client credentials [RFC8252].  Because of this,
   client impersonation should be a concern of anyone deploying this
   pattern.  Without client authentication, a malicious user or attacker
   can mimick the requests the application makes to the authorization
   server, pretending to be the legitimate client.

   Because this specification is intended for first-party applications,
   it is likely that the intent is to also avoid prompting the user with
   a consent screen as recommended by [RFC6749].

   Implementers SHOULD consider additional measures to limit the risk of
   client impersonation, such as using attestation APIs available from
   the operating system.

9.4.  Sender Constrained Tokens

   Tokens issued to native apps SHOULD be sender constrained to mitigate
   the risk of token theft and replay.

   Proof-of-Possession techniques constrain tokens by binding them to a
   cryptographic key.  Whenever the token is presented, it should be
   accompanied by a proof that the client presenting the token also
   controls the cryptographic key bound to the token.  If a proof-of-
   posession sender constrained token is presented without valid proof
   of posession of the cryptographic key, it MUST be rejected.

9.4.1.  Demonstrating Proof-of-Possession

   DPoP is an application-level mechanism for sender-constraining OAuth
   [RFC6749] access and refresh tokens [I-D.ietf-oauth-dpop].  If DPoP
   is used to sender constrain tokens, the native client SHOULD use DPoP
   for every token request to the Authroization Server and interaction
   with the Resource Server.

   DPoP includes an optional capability to bind the authorization code
   to the DPoP key to enable end-to-end binding of the entire
   authorization flow.  If an attacker can access the Authorization Code
   and PKCE code verifier as described in Section 11.9 of
   [I-D.ietf-oauth-dpop], Authorization Code binding SHOULD be used.

   To bind the authorization code using the Authorization Challenge
   Endpoint, the JWK Thumbprint of the DPoP key MUST be communicated to
   the Authorization Server by including the dpop_jkt parameter defined
   in section 10 of [I-D.ietf-oauth-dpop] alongside other authorization
   request parameters in the POST body of the first Authorization
   Challenge Request.  If it is included in subsequent Authorization
   Challenge Requests, the value of this parameter must be the same as
   in the initial request.  If the JWK Thumbprint in the dpop_jkt differ
   at any point, the Authorization Server MUST reject the request.  If
   the dpop_jkt parameter is not included in the first request, but
   added in subsequent requests, the Authorization Server MUST reject
   the request (do we need to define a specific error code for that?).

9.4.2.  Other Proof of Possession Mechanisms

   It may be possible to use other proof of posession mechanisms to
   sender constrain access and refresh tokens.  Defining these
   mechanisms are out of scope for this specification.

9.4.3.  Device Session

   *  PoP binding of device session parameter

9.5.  Multiple Applications

   When there there is more than one 1st-party native applications
   supported by the AS, then it is important to consider a number of
   additional risks.  These risks fall into two main categories:
   Experience Risk and Technical Risk which are described below.

9.5.1.  Experience Risk

   Any time a user is asked to provide the authentication credentials in
   user experiences that differ, it has the effect of increasing the
   likelihood that the user will fall prey to a phishing attack because
   they are used to entering credentials in different looking
   experiences.  When multiple native applications are support, the
   implementation MUST ensure the native experience is identical across
   all the 1st party native applications.

   Another experience risk is user confusion caused by different looking
   experiences and behaviors.  This can increase the likelihood the user
   will not complete the authentication experience for the 1st party
   native application.

9.5.2.  Technical Risk

   In addition to the experience risks, multiple implementations in 1st
   party native applications increases the risk of an incorrect
   implementation as well as increasing the attack surface as each
   implementation may expose it's own weaknesses.

9.5.3.  Mitigation

   To address these risk, when multiple 1st party native applications
   must be supported, and other methods such as [OpenID.Native-SSO] are
   not applicable, it is RECOMMENDED that a client-side SDK be used to
   ensure the implementation is consistent across the different native
   apps and to ensure the user experience is identical for all 1st party
   apps.

10.  IANA Considerations

   TBD

11.  References

11.1.  Normative References

   [I-D.ietf-oauth-dpop]
              Fett, D., Campbell, B., Bradley, J., Lodderstedt, T.,
              Jones, M. B., and D. Waite, "OAuth 2.0 Demonstrating
              Proof-of-Possession at the Application Layer (DPoP)", Work
              in Progress, Internet-Draft, draft-ietf-oauth-dpop-16, 13
              April 2023, <https://datatracker.ietf.org/doc/html/draft-
              ietf-oauth-dpop-16>.

   [I-D.ietf-oauth-step-up-authn-challenge]
              Bertocci, V. and B. Campbell, "OAuth 2.0 Step-up
              Authentication Challenge Protocol", Work in Progress,
              Internet-Draft, draft-ietf-oauth-step-up-authn-challenge-
              17, 26 June 2023, <https://datatracker.ietf.org/doc/html/
              draft-ietf-oauth-step-up-authn-challenge-17>.

   [OpenID]   Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and
              C. Mortimore, "OpenID Connect Core 1.0", November 2014,
              <https://openid.net/specs/openid-connect-core-1_0.html>.

   [OpenID.Native-SSO]
              Fletcher, G., "OpenID Connect Native SSO for Mobile Apps",
              November 2022, <https://openid.net/specs/openid-connect-
              native-sso-1_0.html>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC6749]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              RFC 6749, DOI 10.17487/RFC6749, October 2012,
              <https://www.rfc-editor.org/rfc/rfc6749>.

   [RFC7159]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, DOI 10.17487/RFC7159, March
              2014, <https://www.rfc-editor.org/rfc/rfc7159>.

   [RFC7636]  Sakimura, N., Ed., Bradley, J., and N. Agarwal, "Proof Key
              for Code Exchange by OAuth Public Clients", RFC 7636,
              DOI 10.17487/RFC7636, September 2015,
              <https://www.rfc-editor.org/rfc/rfc7636>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC8259]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, RFC 8259,
              DOI 10.17487/RFC8259, December 2017,
              <https://www.rfc-editor.org/rfc/rfc8259>.

   [RFC8414]  Jones, M., Sakimura, N., and J. Bradley, "OAuth 2.0
              Authorization Server Metadata", RFC 8414,
              DOI 10.17487/RFC8414, June 2018,
              <https://www.rfc-editor.org/rfc/rfc8414>.

   [RFC8707]  Campbell, B., Bradley, J., and H. Tschofenig, "Resource
              Indicators for OAuth 2.0", RFC 8707, DOI 10.17487/RFC8707,
              February 2020, <https://www.rfc-editor.org/rfc/rfc8707>.

11.2.  Informative References

   [RFC8252]  Denniss, W. and J. Bradley, "OAuth 2.0 for Native Apps",
              BCP 212, RFC 8252, DOI 10.17487/RFC8252, October 2017,
              <https://www.rfc-editor.org/rfc/rfc8252>.

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Aaron Parecki
   Okta
   Email: aaron@parecki.com


   George Fletcher
   Capital One Financial
   Email: george.fletcher@capitalone.com


   Pieter Kasselman
   Microsoft
   Email: pieter.kasselman@microsoft.com
